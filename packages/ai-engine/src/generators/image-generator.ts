import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import Replicate from 'replicate';

export interface GenerateImageParams {
  prompt: string;
  width?: number;
  height?: number;
  aspectRatio?: string;
  style?: string;
  index?: number;
  forceRegenerate?: boolean;
}

export interface GeneratedImage {
  success: boolean;
  url?: string;
  filename?: string;
  filepath?: string;
  localPath?: string;
  size?: number;
  cached?: boolean;
  fallback?: boolean;
  searchTerms?: string;
  source: string;
}

export interface ImageGeneratorConfig {
  apiToken: string;
  model?: string;
  maxRetries?: number;
  timeout?: number;
}

export class ImageGenerator {
  private replicate: Replicate;
  private outputDir: string;
  private cacheDir: string;
  private config: ImageGeneratorConfig;

  constructor(config: ImageGeneratorConfig) {
    this.config = config;
    
    // Set up directories
    const baseDir = path.join(process.cwd(), 'generated-images');
    this.outputDir = path.join(baseDir, 'output');
    this.cacheDir = path.join(baseDir, 'cache');
    
    this.ensureDirectories();
    
    // Initialize Replicate
    this.replicate = new Replicate({
      auth: config.apiToken,
    });
  }

  private ensureDirectories() {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
    if (!fs.existsSync(this.cacheDir)) {
      fs.mkdirSync(this.cacheDir, { recursive: true });
    }
  }

  private generateFilename(prompt: string, index = 0): string {
    const hash = crypto.createHash('md5').update(prompt + index).digest('hex');
    return `generated_${hash}.jpeg`;
  }

  private async saveBinaryFile(fileName: string, content: Buffer): Promise<boolean> {
    try {
      await fs.promises.writeFile(fileName, content);
      console.log(`‚úÖ Image saved: ${path.basename(fileName)}`);
      return true;
    } catch (err) {
      console.error(`‚ùå Error saving image ${fileName}:`, err);
      return false;
    }
  }

  private async downloadImage(url: string): Promise<Buffer> {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to download image: ${response.status} ${response.statusText}`);
      }
      const arrayBuffer = await response.arrayBuffer();
      return Buffer.from(arrayBuffer);
    } catch (error: any) {
      throw new Error(`Failed to download image: ${error.message}`);
    }
  }

  async generateImage(params: GenerateImageParams): Promise<GeneratedImage> {
    const {
      prompt,
      width = 1024,
      height = 768,
      aspectRatio = '4:3',
      style = 'photorealistic',
      index = 0,
      forceRegenerate = false
    } = params;

    try {
      console.log(`üé® Generating image with Google Imagen 4...`);
      console.log(`üìù Prompt: ${prompt.substring(0, 100)}...`);
      
      // Generate filename
      let filename = this.generateFilename(prompt, index);
      
      if (forceRegenerate) {
        const timestamp = Date.now();
        filename = `generated_${crypto.createHash('md5').update(prompt + index + timestamp).digest('hex')}.jpeg`;
      }
      
      const cachePath = path.join(this.cacheDir, filename);
      const outputPath = path.join(this.outputDir, filename);
      
      // Check cache
      if (!forceRegenerate && fs.existsSync(cachePath)) {
        console.log(`‚úÖ Using cached image: ${filename}`);
        if (!fs.existsSync(outputPath)) {
          fs.copyFileSync(cachePath, outputPath);
        }
        return {
          success: true,
          filename,
          filepath: outputPath,
          localPath: `/images/generated/${filename}`,
          cached: true,
          source: 'google-imagen-4'
        };
      }
      
      // Generate with Replicate API
      console.log('ü§ñ Calling Replicate API...');
      
      let retryCount = 0;
      const maxRetries = 3;
      let lastError: any = null;
      let currentPrompt = prompt;
      
      while (retryCount < maxRetries) {
        try {
          const input = {
            prompt: currentPrompt,
            aspect_ratio: aspectRatio,
            safety_filter_level: "block_medium_and_above"
          };
          
          console.log(`üìù Creating prediction with prompt: ${currentPrompt.substring(0, 100)}...`);
          const output = await this.replicate.run("google/imagen-4", { input });
          
          if (!output) {
            console.error('‚ùå No image generated by Replicate');
            return this.getFallbackImage(prompt, params);
          }
          
          // Handle different output types
          let imageBuffer: Buffer;
          
          if (output instanceof ReadableStream || (output && typeof (output as any).getReader === 'function')) {
            console.log('üì• Processing image stream...');
            const reader = (output as ReadableStream).getReader();
            const chunks: Uint8Array[] = [];
            
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              chunks.push(value);
            }
            
            imageBuffer = Buffer.concat(chunks.map(chunk => Buffer.from(chunk)));
          } else if (typeof output === 'string') {
            console.log('üì• Downloading generated image...');
            imageBuffer = await this.downloadImage(output);
          } else {
            console.error('‚ùå Unexpected output type:', typeof output);
            return this.getFallbackImage(prompt, params);
          }
          
          // Save to cache and output
          await this.saveBinaryFile(cachePath, imageBuffer);
          await this.saveBinaryFile(outputPath, imageBuffer);
          
          console.log(`‚úÖ Image generated successfully: ${filename}`);
          
          return {
            success: true,
            filename,
            filepath: outputPath,
            localPath: `/images/generated/${filename}`,
            size: imageBuffer.byteLength,
            cached: false,
            source: 'google-imagen-4'
          };
          
        } catch (error: any) {
          lastError = error;
          const errorMsg = error.message || error.toString();
          console.error('‚ùå Replicate API error:', errorMsg);
          
          // Check for safety violations
          if (errorMsg.includes('violated') || errorMsg.includes('Responsible AI') || errorMsg.includes('safety')) {
            retryCount++;
            if (retryCount < maxRetries) {
              console.log(`‚ö†Ô∏è  AI violation detected, retrying with modified prompt (${retryCount}/${maxRetries})...`);
              
              const modifiers = [
                ' Professional photography style.',
                ' Scenic travel photography.',
                ' Beautiful landscape view.',
                ' Tourist destination photography.'
              ];
              currentPrompt = prompt + modifiers[retryCount - 1];
              
              await new Promise(resolve => setTimeout(resolve, 2000));
              continue;
            }
          }
          
          throw error;
        }
      }
      
      throw lastError;
      
    } catch (error: any) {
      console.error(`‚ùå Image generation error:`, error.message);
      
      if (error.message.includes('quota') || error.message.includes('limit')) {
        console.log('üí° Check your Replicate API quota');
      } else if (error.message.includes('401') || error.message.includes('authentication')) {
        console.log('üí° Check your REPLICATE_API_TOKEN');
      }
      
      return this.getFallbackImage(prompt, params);
    }
  }

  private getFallbackImage(prompt: string, options: Partial<GenerateImageParams> = {}): GeneratedImage {
    const { width = 1024, height = 768 } = options;
    
    const searchTerms = this.extractSearchTerms(prompt);
    const unsplashUrl = `https://source.unsplash.com/${width}x${height}/?${searchTerms}`;
    
    console.log(`üîÑ Using Unsplash fallback: ${searchTerms}`);
    
    return {
      success: true,
      url: unsplashUrl,
      fallback: true,
      searchTerms,
      source: 'unsplash-fallback'
    };
  }

  private extractSearchTerms(prompt: string): string {
    const locationKeywords = [
      'barcelona', 'spain', 'madrid', 'seville', 'valencia',
      'paris', 'france', 'london', 'rome', 'italy',
      'new york', 'tokyo', 'dubai', 'sydney', 'rio'
    ];
    
    const activityKeywords = [
      'beach', 'mountain', 'city', 'architecture', 'food',
      'culture', 'museum', 'park', 'nature', 'sunset',
      'tourist', 'landmark', 'view', 'travel', 'vacation'
    ];
    
    const lowerPrompt = prompt.toLowerCase();
    
    // Find matches
    const foundLocation = locationKeywords.find(loc => lowerPrompt.includes(loc));
    const foundActivity = activityKeywords.find(act => lowerPrompt.includes(act));
    
    let searchParts = [];
    
    if (foundLocation) searchParts.push(foundLocation);
    if (foundActivity) searchParts.push(foundActivity);
    
    // If no specific matches, extract key terms
    if (searchParts.length === 0) {
      const cleanPrompt = prompt
        .replace(/professional|high quality|dramatic|aerial|golden hour|photorealistic|ultra|resolution/gi, '')
        .replace(/[,\.\!\?]/g, '')
        .trim();
      
      const words = cleanPrompt.split(' ')
        .filter(word => word.length > 3)
        .slice(0, 3);
      
      searchParts = words;
    }
    
    if (searchParts.length > 0) {
      searchParts.push('travel');
    }
    
    return encodeURIComponent(searchParts.join(','));
  }

  // Compatibility methods for existing interface
  async generateFallbackImage(params: GenerateImageParams): Promise<GeneratedImage> {
    return this.getFallbackImage(params.prompt, params);
  }

  async optimizeImage(imageUrl: string, options: any): Promise<Buffer> {
    // For now, just download the image
    // In a real implementation, you'd use sharp or similar
    console.log('üì• Downloading image for optimization...');
    return this.downloadImage(imageUrl);
  }

  async generateThumbnail(imageUrl: string): Promise<Buffer> {
    // For now, just download the image
    // In a real implementation, you'd resize with sharp
    console.log('üì• Downloading image for thumbnail...');
    return this.downloadImage(imageUrl);
  }
}